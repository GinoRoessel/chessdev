[33mcommit 30c3e9febf012f5206141db1d79bcca6d961e30c[m
Author: Gino Roessel <204071457+GinoRoessel@users.noreply.github.com>
Date:   Mon Apr 14 10:03:03 2025 +0200

    readjusted position arguments, now posx and posy instead of a tuple, next step implementing the sqlalchemy classes

[1mdiff --git a/backend/base.py b/backend/base.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7c2377a[m
[1m--- /dev/null[m
[1m+++ b/backend/base.py[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mfrom sqlalchemy.ext.declarative import declarative_base[m
[32m+[m
[32m+[m[32mBase = declarative_base()[m
\ No newline at end of file[m
[1mdiff --git a/backend/chessboard.py b/backend/chessboard.py[m
[1mindex f3f9ba8..8d98191 100644[m
[1m--- a/backend/chessboard.py[m
[1m+++ b/backend/chessboard.py[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32mfrom base import Base[m
 from chesspieces import *[m
 from chessmove import *[m
 from collections import defaultdict[m
[36m@@ -12,7 +13,8 @@[m [mclass ChessBoard:[m
         self.blackpieces=[][m
         #[m
         self.selected_piece=None[m
[31m-        self.selected_pos=None[m
[32m+[m[32m        self.selected_posy=None[m
[32m+[m[32m        self.selected_posx=None[m
         self.current_player="white"[m
         self.status=" "[m
         self.current_move=None[m
[36m@@ -45,10 +47,14 @@[m [mclass ChessBoard:[m
             self.board[6][i]=Pawn("white")[m
             self.board[1][i]=Pawn("black")[m
             self.board[0][i]=blackpieces_[i][m
[31m-            self.board[7][i].position=(7,i) [m
[31m-            self.board[6][i].position=(6,i)[m
[31m-            self.board[1][i].position=(1,i)[m
[31m-            self.board[0][i].position=(0,i)[m
[32m+[m[32m            self.board[7][i].positiony=7[m[41m [m
[32m+[m[32m            self.board[7][i].positionx=i[m[41m [m
[32m+[m[32m            self.board[6][i].positiony=6[m
[32m+[m[32m            self.board[6][i].positionx=i[m
[32m+[m[32m            self.board[1][i].positiony=1[m
[32m+[m[32m            self.board[1][i].positionx=i[m
[32m+[m[32m            self.board[0][i].positiony=0[m
[32m+[m[32m            self.board[0][i].positionx=i[m
             # print(self.board[0][i])[m
             # print(self.board[0][i].position)[m
             self.piece_lookup[self.board[7][i].symbol,"white"].append(self.board[7][i]) #adding to the lookup_dict[m
[36m@@ -70,11 +76,11 @@[m [mclass ChessBoard:[m
     #     ))[m
     #     return all_pieces[m
         [m
[31m-    def deleting_piece(self,pos): #delete it from all three datastructures[m
[31m-        if self.board[pos[0]][pos[1]]==None:[m
[32m+[m[32m    def deleting_piece(self,posy,posx): #delete it from all three datastructures[m
[32m+[m[32m        if self.board[posy][posx]==None:[m
             return[m
[31m-        key=(self.board[pos[0]][pos[1]].symbol,self.board[pos[0]][pos[1]].color)[m
[31m-        print("key:",key)[m
[32m+[m[32m        key=(self.board[posy][posx].symbol,self.board[posy][posx].color)[m
[32m+[m[32m        # print("key:",key)[m
         if key in self.piece_lookup:[m
             # print("key found")[m
             if isinstance(self.piece_lookup[key],list):[m
[36m@@ -82,19 +88,20 @@[m [mclass ChessBoard:[m
                 # print(self.piece_lookup[key])[m
                 for piece_ in self.piece_lookup[key]:[m
                     # print(piece_.position)[m
[31m-                    if piece_.position==pos:[m
[32m+[m[32m                    if piece_.positiony==posy and piece_.positionx==posx:[m
                         if piece_.color=="white":[m
                             self.whitepieces.remove(piece_)[m
                         elif piece_.color=="black":[m
                             self.blackpieces.remove(piece_)[m
[31m-                            print("how many blackpieces left:",len(self.blackpieces))[m
[32m+[m[32m                            # print("how many blackpieces left:",len(self.blackpieces))[m
                         self.piece_lookup[key].remove(piece_)[m
[32m+[m[32m                        self.board[posy][posx]==None[m
                         return[m
                     [m
     # def update_board(self,move_):[m
     #     if move_.is_enpassant==False and move_.is_castle==False and move_.is_promotion==False:[m
[31m-    #         self.storage=self.board[move_.startpos[0]][move_.startpos[1]][m
[31m-    #         self.storage_gonepiece=self.board[move_.endpos[0]][move_.endpos[1]][m
[32m+[m[32m    #         self.storage=self.board[move_.startposy][move_.startposx][m
[32m+[m[32m    #         self.storage_gonepiece=self.board[move_.endposy][move_.endposx][m
     #         self.make_move(move_)[m
     #     elif move_.is_enpassant==True:[m
     #         ### hier weitermachen[m
[36m@@ -104,23 +111,23 @@[m [mclass ChessBoard:[m
     #     elif move_.is_promotion==True:[m
     #         self.make_move(move_)[m
         ##[m
[31m-        # self.storage=self.board[move__.endpos[0]][move__.endpos[1]][m
[31m-        # self.deleting_piece((move__.endpos[0],move__.endpos[1]))[m
[31m-        # self.board[move__.endpos[0]][move__.endpos[1]]=move__.piece[m
[31m-        # self.board[move__.startpos[0]][move__.startpos[1]]=None[m
[31m-        # move__.piece.position=(move__.endpos[0],move__.endpos[1])[m
[32m+[m[32m        # self.storage=self.board[move__.endposy][move__.endposx][m
[32m+[m[32m        # self.deleting_piece((move__.endposy,move__.endposx))[m
[32m+[m[32m        # self.board[move__.endposy][move__.endposx]=move__.piece[m
[32m+[m[32m        # self.board[move__.startposy][move__.startposx]=None[m
[32m+[m[32m        # move__.piece.position=(move__.endposy,move__.endposx)[m
 [m
     # def deupdate_board(self,move__):[m
[31m-    #     self.board[move__.startpos[0]][move__.startpos[1]]=self.board[move__.startpos[0]][move__.startpos[1]]=move__.piece[m
[31m-    #     move__.piece.position=(move__.startpos[0],move__.startpos[1])[m
[31m-    #     self.board[move__.endpos[0]][move__.endpos[1]]=self.storage[m
[32m+[m[32m    #     self.board[move__.startposy][move__.startposx]=self.board[move__.startposy][move__.startposx]=move__.piece[m
[32m+[m[32m    #     move__.piece.position=(move__.startposy,move__.startposx)[m
[32m+[m[32m    #     self.board[move__.endposy][move__.endposx]=self.storage[m
     #     if self.storage!=None:[m
[31m-    #         self.board[move__.endpos[0]][move__.endpos[1]].position=(move__.endpos[0],move__.endpos[1])[m
[31m-    #         self.piece_lookup[self.board[move__.endpos[0]][move__.endpos[1]].symbol,self.board[move__.endpos[0]][move__.endpos[1]].color].append(self.board[move__.endpos[0]][move__.endpos[1]])[m
[31m-    #         if self.board[move__.endpos[0]][move__.endpos[1]].color=="white":[m
[31m-    #             self.whitepieces.append(self.board[move__.endpos[0]][move__.endpos[1]])[m
[31m-    #         elif self.board[move__.endpos[0]][move__.endpos[1]].color=="black":[m
[31m-    #             self.blackpieces.append(self.board[move__.endpos[0]][move__.endpos[1]])[m
[32m+[m[32m    #         self.board[move__.endposy][move__.endposx].position=(move__.endposy,move__.endposx)[m
[32m+[m[32m    #         self.piece_lookup[self.board[move__.endposy][move__.endposx].symbol,self.board[move__.endposy][move__.endposx].color].append(self.board[move__.endposy][move__.endposx])[m
[32m+[m[32m    #         if self.board[move__.endposy][move__.endposx].color=="white":[m
[32m+[m[32m    #             self.whitepieces.append(self.board[move__.endposy][move__.endposx])[m
[32m+[m[32m    #         elif self.board[move__.endposy][move__.endposx].color=="black":[m
[32m+[m[32m    #             self.blackpieces.append(self.board[move__.endposy][move__.endposx])[m
 [m
 [m
     def make_move(self,move_): #updating the data structures for a complete move[m
[36m@@ -128,80 +135,90 @@[m [mclass ChessBoard:[m
         # self.chessboard_.current_move=Rules.extract_moves_from_informations(piece,startrow,startcol,endrow,endcol,self.chessboard_.ruleset_,self.chessboard_,self.promotion_choice_)[m
         # for move in self.chessboard_.current_move:[m
         if move_.is_enpassant==False and move_.is_castle==False and move_.is_promotion==False:[m
[32m+[m[32m            # print("normaler move")[m
             self.make_single_move(move_)[m
         elif move_.is_enpassant==True:[m
             self.make_single_move(move_)[m
[31m-            self.make_single_move(ChessMove(move_.captured_piece_pos,(None,None),move_.captured_piece))[m
[32m+[m[32m            self.make_single_move(ChessMove(move_.captured_piece_posy,move_.captured_piece_posx,None,None,move_.captured_piece))[m
         elif move_.is_castle==True:[m
             self.make_single_move(move_)[m
[31m-            self.make_single_move(ChessMove(move_.castle_secondpiece_pos,(move_.startpos[0],(move_.startpos[1]+move_.endpos[1])//2),move_.castle_secondpiece))[m
[32m+[m[32m            self.make_single_move(ChessMove(move_.castle_secondpiece_posy,move_.castle_secondpiece_posx,move_.startposy,(move_.startposx+move_.endposx)//2,move_.castle_secondpiece))[m
         elif move_.is_promotion==True:[m
             self.make_single_move(move_)[m
[31m-            p_move=ChessMove(move_.endpos,(None,None),move_.piece)[m
[32m+[m[32m            p_move=ChessMove(move_.endposy,move_.endposx,None,None,move_.piece)[m
             self.make_single_move(p_move)[m
[31m-            print("promo choice",move_.promotion_choice)[m
[31m-            self.make_single_move(ChessMove((None,None),move_.endpos,move_.promotion_choice))[m
[32m+[m[32m            # print("promo choice",move_.promotion_choice)[m
[32m+[m[32m            self.make_single_move(ChessMove(None,None,move_.endposy,move_.endposx,move_.promotion_choice))[m
         self.move_list.append(move_)[m
 [m
 [m
 [m
     def make_single_move(self,move_): #updating the data structures for a single move[m
[31m-        if move_.endpos[0]!=None and move_.endpos[1]!=None and move_.startpos[0]!=None and move_.startpos[1]!=None: #normal move[m
[31m-            self.deleting_piece((move_.endpos[0],move_.endpos[1]))[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]]=move_.piece[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]].position=(move_.endpos[0],move_.endpos[1])[m
[31m-        if move_.endpos[0]==None and move_.endpos[1]==None and move_.startpos[0]!=None and move_.startpos[1]!=None: #delete a piece[m
[31m-            self.deleting_piece((move_.startpos[0],move_.startpos[1]))[m
[31m-        if move_.startpos[0]==None and move_.startpos[1]==None and move_.endpos[1]!=None and move_.endpos[0]!=None: #spawn new piece[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]]=move_.piece[m
[31m-            print(move_.piece)[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]].position=(move_.endpos[0],move_.endpos[1])[m
[31m-            self.piece_lookup[self.board[move_.endpos[0]][move_.endpos[1]].symbol,self.board[move_.endpos[0]][move_.endpos[1]].color].append(self.board[move_.endpos[0]][move_.endpos[1]])[m
[32m+[m[32m        if move_.endposy!=None and move_.endposx!=None and move_.startposy!=None and move_.startposx!=None: #normal move[m
[32m+[m[32m            self.deleting_piece(move_.endposy,move_.endposx)[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx]=move_.piece[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx].positiony=move_.endposy[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx].positionx=move_.endposx[m
[32m+[m[32m        if move_.endposy==None and move_.endposx==None and move_.startposy!=None and move_.startposx!=None: #delete a piece[m
[32m+[m[32m            self.deleting_piece(move_.startposy,move_.startposx)[m
[32m+[m[32m        if move_.startposy==None and move_.startposx==None and move_.endposx!=None and move_.endposy!=None: #spawn new piece[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx]=move_.piece[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx].positiony=move_.endposy[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx].positionx=move_.endposx[m
[32m+[m[32m            self.piece_lookup[self.board[move_.endposy][move_.endposx].symbol,self.board[move_.endposy][move_.endposx].color].append(self.board[move_.endposy][move_.endposx])[m
             if move_.piece.color=="white":[m
[31m-                self.whitepieces.append(self.board[move_.endpos[0]][move_.endpos[1]])[m
[32m+[m[32m                self.whitepieces.append(self.board[move_.endposy][move_.endposx])[m
             else:[m
[31m-                self.blackpieces.append(self.board[move_.endpos[0]][move_.endpos[1]])[m
[31m-        if move_.startpos[0]!=None and move_.startpos[1]!=None: #always except new thing spawned[m
[31m-            self.board[move_.startpos[0]][move_.startpos[1]]=None[m
[32m+[m[32m                self.blackpieces.append(self.board[move_.endposy][move_.endposx])[m
[32m+[m[32m        if move_.startposy!=None and move_.startposx!=None: #always except new thing spawned[m
[32m+[m[32m            self.board[move_.startposy][move_.startposx]=None[m
 [m
     def take_move_back(self,move_):[m
         if move_.is_enpassant==False and move_.is_castle==False and move_.is_promotion==False:[m
             self.take_single_move_back(move_)[m
[32m+[m[32m            # print("before recreation of captured piece")[m
             if move_.captured_piece!=None:[m
[31m-                self.take_single_move_back(ChessMove(move_.captured_piece_pos,(None,None),move_.captured_piece))[m
[32m+[m[32m                # print("recreation of captured piece")[m
[32m+[m[32m                self.take_single_move_back(ChessMove(move_.captured_piece_posy,move_.captured_piece_posx,None,None,move_.captured_piece))[m
         elif move_.is_enpassant==True:[m
             self.take_single_move_back(move_)[m
[31m-            self.take_single_move_back(ChessMove(move_.captured_piece_pos,(None,None),move_.captured_piece))[m
[32m+[m[32m            self.take_single_move_back(ChessMove(move_.captured_piece_posy,move_.captured_piece_posx,None,None,move_.captured_piece))[m
         elif move_.is_castle==True:[m
             self.take_single_move_back(move_)[m
[31m-            self.take_single_move_back(ChessMove(move_.castle_secondpiece_pos,(move_.startpos[0],(move_.startpos[1]+move_.endpos[1])//2),move_.castle_secondpiece))[m
[32m+[m[32m            self.take_single_move_back(ChessMove(move_.captured_piece_posy,move_.captured_piece_posx,move_.startposy,(move_.startposx+move_.endposx)//2,move_.castle_secondpiece))[m
         elif move_.is_promotion==True:[m
[31m-            self.make_single_move(ChessMove((None,None),move_.endpos,move_.promotion_choice))[m
[31m-            p_move=ChessMove(move_.endpos,(None,None),move_.piece)[m
[32m+[m[32m            self.make_single_move(ChessMove(None,None,move_.endposy,move_.endposx,move_.promotion_choice))[m
[32m+[m[32m            p_move=ChessMove(move_.endposy,move_.endposx,None,None,move_.piece)[m
             self.take_single_move_back(p_move)[m
             self.take_single_move_back(move_)[m
             if move_.captured_piece!=None:[m
[31m-                self.take_single_move_back(ChessMove(move_.captured_piece_pos,(None,None),move_.captured_piece))[m
[32m+[m[32m                self.take_single_move_back(ChessMove(move_.captured_piece_posy,move_.captured_piece_posx,None,None,move_.captured_piece))[m
         self.move_list.pop()[m
             [m
 [m
     def take_single_move_back(self,move_):[m
[31m-        if move_.endpos[0]!=None and move_.endpos[1]!=None and move_.startpos[0]!=None and move_.startpos[1]!=None: #normal move[m
[31m-            self.board[move_.startpos[0]][move_.startpos[1]]=move_.piece[m
[31m-            self.board[move_.startpos[0]][move_.startpos[1]].position=(move_.startpos[0],move_.startpos[1])[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]]=None[m
[31m-        if move_.endpos[0]==None and move_.endpos[1]==None and move_.startpos[0]!=None and move_.startpos[1]!=None: #delete a piece[m
[31m-            self.create_piece((move_.startpos[0],move_.startpos[1]),move_.piece)[m
[31m-        if move_.startpos[0]==None and move_.startpos[1]==None and move_.endpos[1]!=None and move_.endpos[0]!=None: #spawn new piece[m
[31m-            self.deleting_piece(move_.endpos)[m
[31m-        if move_.endpos[0]!=None and move_.endpos[1]!=None: #always except new thing spawned[m
[31m-            self.board[move_.endpos[0]][move_.endpos[1]]=None[m
[32m+[m[32m        if move_.endposy!=None and move_.endposx!=None and move_.startposy!=None and move_.startposx!=None: #normal move[m
[32m+[m[32m            self.board[move_.startposy][move_.startposx]=move_.piece[m
[32m+[m[32m            self.board[move_.startposy][move_.startposx].positiony=move_.startposy[m
[32m+[m[32m            self.board[move_.startposy][move_.startposx].positionx=move_.startposx[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx]=None[m
[32m+[m[32m        if move_.endposy==None and move_.endposx==None and move_.startposy!=None and move_.startposx!=None: #delete a piece[m
[32m+[m[32m            self.create_piece(move_.startposy,move_.startposx,move_.piece)[m
[32m+[m[32m            # print("takeback smth")[m
[32m+[m[32m            # if move_.piece.symbol=="Q":[m
[32m+[m[32m            #     print("takeback a queen")[m
[32m+[m[32m        if move_.startposy==None and move_.startposx==None and move_.endposx!=None and move_.endposy!=None: #spawn new piece[m
[32m+[m[32m            self.deleting_piece(move_.endposy,move_.endposx)[m
[32m+[m[32m        if move_.endposy!=None and move_.endposx!=None: #always except new thing spawned[m
[32m+[m[32m            self.board[move_.endposy][move_.endposx]=None[m
 [m
[31m-    def create_piece(self,pos,piece):[m
[31m-        self.board[pos[0]][pos[1]]=piece[m
[31m-        self.board[pos[0]][pos[1]].position=(pos[0],pos[1])[m
[31m-        self.piece_lookup[self.board[pos[0]][pos[1]].symbol,self.board[pos[0]][pos[1]].color].append(self.board[pos[0]][pos[1]])[m
[32m+[m[32m    def create_piece(self,posy,posx,piece):[m
[32m+[m[32m        # print("something created")[m
[32m+[m[32m        self.board[posy][posx]=piece[m
[32m+[m[32m        self.board[posy][posx].positiony=posy[m
[32m+[m[32m        self.board[posy][posx].positionx=posx[m
[32m+[m[32m        self.piece_lookup[self.board[posy][posx].symbol,self.board[posy][posx].color].append(self.board[posy][posx])[m
         if piece.color=="white":[m
[31m-            self.whitepieces.append(self.board[pos[0]][pos[1]])[m
[32m+[m[32m            self.whitepieces.append(self.board[posy][posx])[m
         else:[m
[31m-            self.blackpieces.append(self.board[pos[0]][pos[1]])[m
\ No newline at end of file[m
[32m+[m[32m            self.blackpieces.append(self.board[posy][posx])[m
\ No newline at end of file[m
[1mdiff --git a/backend/chessgame.py b/backend/chessgame.py[m
[1mindex df18855..18d88a2 100644[m
[1m--- a/backend/chessgame.py[m
[1m+++ b/backend/chessgame.py[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32mfrom base import Base[m
 import tkinter as tk[m
 from chesspieces import *[m
 from chessmove import *[m
[36m@@ -17,9 +18,10 @@[m [mclass ChessGame:[m
 [m
     [m
     def on_square_click(self,r,c): #button command[m
[32m+[m[32m        print("touched")[m
         if self.chessboard_.status!="white is mated, game over" and self.chessboard_.status!="black is mated, game over":[m
             if self.chessboard_.selected_piece!=None:[m
[31m-                move_to_prove=ChessMove((self.chessboard_.selected_pos[0],self.chessboard_.selected_pos[1]),(r,c),[m
[32m+[m[32m                move_to_prove=ChessMove(self.chessboard_.selected_posy,self.chessboard_.selected_posx,r,c,[m
                                         self.chessboard_.selected_piece)[m
                 self.chessboard_.current_move=self.checking_move(move_to_prove)[m
                 if self.chessboard_.current_move:[m
[36m@@ -31,30 +33,39 @@[m [mclass ChessGame:[m
                     if self.changes_gui_:[m
                         move_=self.chessboard_.current_move[m
                         if move_.is_enpassant==False and move_.is_castle==False and move_.is_promotion==False:[m
[31m-                            self.changes_gui_(move_.startpos[0],move_.startpos[1],self.chessboard_.board[move_.startpos[0]][move_.startpos[1]])[m
[31m-                            self.changes_gui_(move_.endpos[0],move_.endpos[1],self.chessboard_.board[move_.endpos[0]][move_.endpos[1]])[m
[32m+[m[32m                            # print("startpos",move_.startposy,move_.startposx)[m
[32m+[m[32m                            # print("endpos",move_.endposy,move_.endposx)[m
[32m+[m[32m                            self.changes_gui_(move_.startposy,move_.startposx,self.chessboard_.board[move_.startposy][move_.startposx])[m
[32m+[m[32m                            # print(self.chessboard_.board[move_.endposy][move_.endposx])[m
[32m+[m[32m                            self.changes_gui_(move_.endposy,move_.endposx,self.chessboard_.board[move_.endposy][move_.endposx])[m
                         elif move_.is_enpassant==True:[m
[31m-                            self.changes_gui_(move_.startpos[0],move_.startpos[1],self.chessboard_.board[move_.startpos[0]][move_.startpos[1]])[m
[31m-                            self.changes_gui_(move_.endpos[0],move_.endpos[1],self.chessboard_.board[move_.endpos[0]][move_.endpos[1]])[m
[31m-                            self.changes_gui_(move_.captured_piece.position[0],move_.captured_piece.position[1],self.chessboard_.board[move_.captured_piece.position[0]][move_.captured_piece.position[1]])[m
[32m+[m[32m                            self.changes_gui_(move_.startposy,move_.startposx,self.chessboard_.board[move_.startposy][move_.startposx])[m
[32m+[m[32m                            self.changes_gui_(move_.endposy,move_.endposx,self.chessboard_.board[move_.endposy][move_.endposx])[m
[32m+[m[32m                            self.changes_gui_(move_.captured_piece.positiony,move_.captured_piece.positionx,self.chessboard_.board[move_.captured_piece_posy][move_.captured_piece_posx])[m
                         elif move_.is_castle==True:[m
[31m-                            self.changes_gui_(move_.startpos[0],move_.startpos[1],self.chessboard_.board[move_.startpos[0]][move_.startpos[1]])[m
[31m-                            self.changes_gui_(move_.endpos[0],move_.endpos[1],self.chessboard_.board[move_.endpos[0]][move_.endpos[1]])[m
[31m-                            self.changes_gui_(move_.castle_secondpiece_pos[0],move_.castle_secondpiece_pos[1],self.chessboard_.board[move_.castle_secondpiece_pos[0]][move_.castle_secondpiece_pos[1]])[m
[31m-                            self.changes_gui_(move_.startpos[0],(move_.startpos[1]+move_.endpos[1])//2,self.chessboard_.board[move_.startpos[0]][(move_.startpos[1]+move_.endpos[1])//2])[m
[32m+[m[32m                            self.changes_gui_(move_.startposy,move_.startposx,self.chessboard_.board[move_.startposy][move_.startposx])[m
[32m+[m[32m                            self.changes_gui_(move_.endposy,move_.endposx,self.chessboard_.board[move_.endposy][move_.endposx])[m
[32m+[m[32m                            self.changes_gui_(move_.castle_secondpiece_posy,move_.castle_secondpiece_posx,self.chessboard_.board[move_.castle_secondpiece_posy][move_.castle_secondpiece_posx])[m
[32m+[m[32m                            self.changes_gui_(move_.startposy,(move_.startposx+move_.endposx)//2,self.chessboard_.board[move_.startposy][(move_.startposx+move_.endposx)//2])[m
                         elif move_.is_promotion==True:[m
[31m-                            self.changes_gui_(move_.startpos[0],move_.startpos[1],self.chessboard_.board[move_.startpos[0]][move_.startpos[1]])[m
[31m-                            self.changes_gui_(move_.endpos[0],move_.endpos[1],self.chessboard_.board[move_.endpos[0]][move_.endpos[1]])[m
[32m+[m[32m                            self.changes_gui_(move_.startposy,move_.startposx,self.chessboard_.board[move_.startposy][move_.startposx])[m
[32m+[m[32m                            self.changes_gui_(move_.endposy,move_.endposx,self.chessboard_.board[move_.endposy][move_.endposx])[m
 [m
                 self.chessboard_.selected_piece=None[m
[31m-                self.chessboard_.selected_pos=None[m
[32m+[m[32m                self.chessboard_.selected_posy=None[m
[32m+[m[32m                self.chessboard_.selected_posx=None[m
                 # print(self.chessboard_.selected_pos)[m
                 # print(self.chessboard_.selected_piece)[m
             else:[m
[32m+[m[32m                # print("select piece check")[m
                 piece=self.chessboard_.board[r][c][m
[32m+[m[32m                # print(piece)[m
[32m+[m[32m                # print(self.chessboard_.piece_lookup["Q","white"])[m
                 if piece and piece.color==self.chessboard_.current_player: [m
[32m+[m[32m                    # print("valid selelct piece")[m
                     self.chessboard_.selected_piece=self.chessboard_.board[r][c][m
[31m-                    self.chessboard_.selected_pos=(r,c)[m
[32m+[m[32m                    self.chessboard_.selected_posy=r[m
[32m+[m[32m                    self.chessboard_.selected_posx=c[m
                     # print(self.chessboard_.selected_pos)[m
                     # print(self.chessboard_.selected_piece)[m
     [m
[36m@@ -74,7 +85,8 @@[m [mclass ChessGame:[m
     def restartgame(self):[m
         self.chessboard_.setup_board(self.chessboard_.ruleset_) [m
         self.chessboard_.selected_piece=None[m
[31m-        self.chessboard_.selected_pos=None[m
[32m+[m[32m        self.chessboard_.selected_posy=None[m
[32m+[m[32m        self.chessboard_.selected_posx=None[m
         self.chessboard_.current_player="white"[m
         self.chessboard_.status=" "[m
         if self.setup_gui_:[m
[1mdiff --git a/backend/chessmove.py b/backend/chessmove.py[m
[1mindex 39bcdc3..cc569bd 100644[m
[1m--- a/backend/chessmove.py[m
[1m+++ b/backend/chessmove.py[m
[36m@@ -1,15 +1,60 @@[m
[32m+[m[32mfrom base import Base[m
[32m+[m[32mfrom sqlalchemy import Column, Integer, String, Boolean[m
[32m+[m
 class ChessMove():[m
[31m-    def __init__(self,startpos,endpos,piece,captured_piece=None,captured_piece_pos=None,is_enpassant=False,[m
[31m-                 is_castle=False,is_promotion=False,promotion_choice=None,[m
[31m-                 castle_secondpiece=None,castle_secondpiece_pos=None):[m
[31m-        self.startpos=startpos[m
[31m-        self.endpos=endpos[m
[32m+[m[32m    def __init__(self,startposy,startposx,endposy,endposx,piece,captured_piece=None,captured_piece_posy=None,captured_piece_posx=None,[m
[32m+[m[32m                 is_enpassant=False,is_castle=False,is_promotion=False,promotion_choice=None,[m
[32m+[m[32m                 castle_secondpiece=None,castle_secondpiece_posy=None,castle_secondpiece_posx=None):[m
[32m+[m[32m        self.startposy=startposy[m
[32m+[m[32m        self.startposx=startposx[m
[32m+[m[32m        self.endposy=endposy[m
[32m+[m[32m        self.endposx=endposx[m
         self.piece=piece[m
         self.captured_piece=captured_piece[m
[31m-        self.captured_piece_pos=captured_piece_pos[m
[32m+[m[32m        self.captured_piece_posy=captured_piece_posy[m
[32m+[m[32m        self.captured_piece_posx=captured_piece_posx[m
         self.is_enpassant=is_enpassant[m
         self.is_castle=is_castle[m
         self.is_promotion=is_promotion[m
         self.promotion_choice=promotion_choice[m
         self.castle_secondpiece=castle_secondpiece[m
[31m-        self.castle_secondpiece_pos=castle_secondpiece_pos[m
\ No newline at end of file[m
[32m+[m[32m        self.castle_secondpiece_posy=castle_secondpiece_posy[m
[32m+[m[32m        self.castle_secondpiece_posx=castle_secondpiece_posx[m
[32m+[m
[32m+[m[32mclass _ChessMove(Base):[m
[32m+[m[32m    __tablename__ = 'chess_moves'[m
[32m+[m
[32m+[m[32m    id = Column(Integer, primary_key=True)[m
[32m+[m[32m    startposy = Column(Integer)[m
[32m+[m[32m    startposx = Column(Integer)[m
[32m+[m[32m    endposy = Column(Integer)[m
[32m+[m[32m    endposy = Column(Integer)[m
[32m+[m[32m    piece = Column(String) ##noch json[m
[32m+[m[32m    captured_piece = Column(String, nullable=True) ##noch json[m
[32m+[m[32m    captured_piece_posy = Column(Integer, nullable=True)[m
[32m+[m[32m    captured_piece_posx = Column(Integer, nullable=True)[m
[32m+[m[32m    is_enpassant = Column(Boolean, default=False)[m
[32m+[m[32m    is_castle = Column(Boolean, default=False)[m
[32m+[m[32m    is_promotion = Column(Boolean, default=False)[m
[32m+[m[32m    promotion_choice = Column(String, nullable=True) ##noch json[m
[32m+[m[32m    castle_secondpiece = Column(String, nullable=True) ##noch json[m
[32m+[m[32m    castle_secondpiece_posy = Column(Integer, nullable=True)[m
[32m+[m[32m    castle_secondpiece_posx = Column(Integer, nullable=True)[m
[32m+[m[32m    def __init__(self,startposy,startposx,endposy,endposx,piece,captured_piece=None,captured_piece_posy=None,captured_piece_posx=None,[m
[32m+[m[32m                 is_enpassant=False,is_castle=False,is_promotion=False,promotion_choice=None,[m
[32m+[m[32m                 castle_secondpiece=None,castle_secondpiece_posy=None,castle_secondpiece_posx=None):[m
[32m+[m[32m        self.startposy=startposy[m
[32m+[m[32m        self.startposx=startposx[m
[32m+[m[32m        self.endposy=endposy[m
[32m+[m[32m        self.endposx=endposx[m
[32m+[m[32m        self.piece=piece[m
[32m+[m[32m        self.captured_piece=captured_piece[m
[32m+[m[32m        self.captured_piece_posy=captured_piece_posy[m
[32m+[m[32m        self.captured_piece_posx=captured_piece_posx[m
[32m+[m[32m        self.is_enpassant=is_enpassant[m
[32m+[m[32m        self.is_castle=is_castle[m
[32m+[m[32m        self.is_promotion=is_promotion[m
[32m+[m[32m        self.promotion_choice=promotion_choice[m
[32m+[m[32m        self.castle_secondpiece=castle_secondpiece[m
[32m+[m[32m        self.castle_secondpiece_posy=castle_secondpiece_posy[m
[32m+[m[32m        self.castle_secondpiece_posx=castle_secondpiece_posx[m
\ No newline at end of file[m
[1mdiff --git a/backend/chesspieces.py b/backend/chesspieces.py[m
[1mindex 3f91c46..719eb60 100644[m
[1m--- a/backend/chesspieces.py[m
[1m+++ b/backend/chesspieces.py[m
[36m@@ -1,4 +1,5 @@[m
[31m-class ChessPieces:[m
[32m+[m[32mfrom base import Base[m
[32m+[m[32mclass _ChessPieces:[m
     def __init__(self,color,symbol,guisymbol):[m
         self.color=color[m
         self.guisymbol=guisymbol #unicode[m
[36m@@ -8,6 +9,17 @@[m [mclass ChessPieces:[m
     def __str__(self):[m
         return self.guisymbol[m
     [m
[32m+[m[32mclass ChessPieces:[m
[32m+[m[32m    def __init__(self,color,symbol,guisymbol):[m
[32m+[m[32m        self.color=color[m
[32m+[m[32m        self.guisymbol=guisymbol #unicode[m
[32m+[m[32m        self.positionx=None[m
[32m+[m[32m        self.positiony=None[m
[32m+[m[32m        self.symbol=symbol #letter[m
[32m+[m[41m    [m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return self.guisymbol[m
[32m+[m[41m    [m
         [m
 class Queen(ChessPieces):[m
     def __init__(self,color):[m
[1mdiff --git a/backend/requirements.txt b/backend/requirements.txt[m
[1mindex 1b6ba71..dd74076 100644[m
[1m--- a/backend/requirements.txt[m
[1m+++ b/backend/requirements.txt[m
[36m@@ -1 +1,3 @@[m
[31m-##[m
\ No newline at end of file[m
[32m+[m[32mgreenlet==3.1.1[m
[32m+[m[32mSQLAlchemy==2.0.40[m
[32m+[m[32mtyping_extensions==4.13.2[m
[1mdiff --git a/chessrules.py b/chessrules.py[m
[1mdeleted file mode 100644[m
[1mindex c131b46..0000000[m
[1m--- a/chessrules.py[m
[1m+++ /dev/null[m
[36m@@ -1,414 +0,0 @@[m
[31m-from chesspieces import *[m
[31m-from chessmove import *[m
[31m-[m
[31m-[m
[31m-class Rules: #just staticmethods[m
[31m-    def __init__(self,ruleset):[m
[31m-        pass[m
[31m-[m
[31m-            [m
[31m-    @staticmethod #complete check of a move[m
[31m-    def is_valid_move(move__,board,promotion_choice=None,justtest=False):[m
[31m-        move_=Rules.is_possible_move(move__,board,justtest)[m
[31m-        if not move_:[m
[31m-            return False[m
[31m-        print("is_valid_move: Rufe testing_move auf")[m
[31m-        move_=Rules.testing_move(move_,board,promotion_choice,justtest)[m
[31m-        if not move_:[m
[31m-            print("not working after test")[m
[31m-            return False[m
[31m-        # print("valid")[m
[31m-[m
[31m-        return move_[m
[31m-    [m
[31m-    @staticmethod #if the logic of the piece would allow the move[m
[31m-    def is_possible_move(move__,board,justtest):[m
[31m-        if board.ruleset_=="classical":[m
[31m-            if Rules.is_own_piece(move__,board) is True:[m
[31m-                print("is an own piece")[m
[31m-                return False[m
[31m-            if (move__.startpos[0],move__.startpos[1])==(move__.endpos[0],move__.endpos[1]):[m
[31m-                print("not changed the position")[m
[31m-                return False[m
[31m-            if isinstance(move__.piece,Pawn):[m
[31m-                return Rules.is_possible_pawnmove_classical(move__,board,justtest)[m
[31m-            elif isinstance(move__.piece,Rook):[m
[31m-                return Rules.is_possible_rookmove_classical(move__,board,justtest)[m
[31m-            elif isinstance(move__.piece,Knight):[m
[31m-                return Rules.is_possible_knightmove_classical(move__,board,justtest)[m
[31m-            elif isinstance(move__.piece,Bishop):[m
[31m-                return Rules.is_possible_bishopmove_classical(move__,board,justtest)[m
[31m-            elif isinstance(move__.piece,Queen):[m
[31m-                return Rules.is_possible_queenmove_classical(move__,board,justtest)[m
[31m-            elif isinstance(move__.piece,King):[m
[31m-                return Rules.is_possible_kingmove_classical(move__,board,justtest)[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def is_possible_pawnmove_classical(move__,board,justtest):[m
[31m-        # print("piece is",piece)[m
[31m-        # print("startrow is",startrow)[m
[31m-        # print("startcol is",startcol)[m
[31m-        # print("endrow is",endrow)[m
[31m-        # print("endcol is",endcol)[m
[31m-        direction=-1 if move__.piece.color=="white" else 1[m
[31m-        if move__.startpos[1]==move__.endpos[1]: #geradeaus[m
[31m-            if move__.endpos[0]-move__.startpos[0]==direction and board.board[move__.endpos[0]][move__.endpos[1]] is None: #ein Feld[m
[31m-                if move__.endpos[0]==0 or move__.endpos[0]==7:[m
[31m-                    if not justtest:[m
[31m-                        move__.is_promotion=True[m
[31m-                return move__[m
[31m-            if move__.endpos[0]-move__.startpos[0]==2*direction and move__.startpos[0]==(6 if move__.piece.color == "white" else 1)\[m
[31m-                and board.board[move__.endpos[0]][move__.endpos[1]] is None and board.board[(move__.endpos[0]+move__.startpos[0])//2][move__.endpos[1]] is None: #zwei Felder[m
[31m-                return move__[m
[31m-        try: [m
[31m-            if (move__.startpos[1]+1==move__.endpos[1] or move__.startpos[1]-1==move__.endpos[1]) and move__.endpos[0]-move__.startpos[0]==direction\[m
[31m-              and board.board[move__.endpos[0]][move__.endpos[1]].color!=move__.piece.color: #diagonal schlagen[m
[31m-                move__.captured_piece=board.board[move__.endpos[0]][move__.endpos[1]][m
[31m-                move__.captured_piece_pos=(move__.endpos[0],move__.endpos[1])[m
[31m-                if move__.endpos[0]==0 or move__.endpos[0]==7:[m
[31m-                    if not justtest:[m
[31m-                        move__.is_promotion=True[m
[31m-                return move__[m
[31m-        except AttributeError:[m
[31m-            pass[m
[31m-        #en passant[m
[31m-        try:[m
[31m-            if (move__.startpos[1]+1==move__.endpos[1] or move__.startpos[1]-1==move__.endpos[1])\[m
[31m-            and move__.endpos[0]-move__.startpos[0]==direction\[m
[31m-            and move__.startpos[0]==(3 if move__.piece.color=="white" else 4)\[m
[31m-            and board.board[move__.startpos[0]][move__.endpos[1]].color!=move__.piece.color\[m
[31m-            and board.move_list[-1].endpos==(move__.startpos[0],move__.endpos[1]):[m
[31m-                if not justtest:[m
[31m-                    move__.captured_piece=board.board[move__.startpos[0]][move__.endpos[1]][m
[31m-                    move__.captured_piece_pos=(move__.startpos[0],move__.endpos[1])[m
[31m-                    move__.is_enpassant=True[m
[31m-                return move__[m
[31m-        except AttributeError:[m
[31m-            pass[m
[31m-[m
[31m-        return False[m
[31m-            [m
[31m-[m
[31m-    @staticmethod[m
[31m-    def is_possible_rookmove_classical(move__,board,justtest):[m
[31m-        if move__.startpos[0]==move__.endpos[0] or move__.startpos[1]==move__.endpos[1]:[m
[31m-            return Rules.is_path_clear_rook_classical(move__,board,justtest)[m
[31m-        return False[m
[31m-[m
[31m-    def is_path_clear_rook_classical(move__,board,justtest):[m
[31m-        if move__.startpos[0]==move__.endpos[0]:[m
[31m-            direction=1 if move__.startpos[1]<move__.endpos[1] else -1[m
[31m-            # if abs(endcol-startcol)==1:[m
[31m-            #     return True[m
[31m-            for i in range(1,abs(move__.endpos[1]-move__.startpos[1])):[m
[31m-                if board.board[move__.startpos[0]][move__.startpos[1]+(i*direction)] is not None:[m
[31m-                    return False[m
[31m-            if not justtest:[m
[31m-                move__.captured_piece=board.board[move__.endpos[0]][move__.endpos[1]][m
[31m-                move__.captured_piece_pos=(move__.endpos[0],move__.endpos[1])[m
[31m-            return move__  [m
[31m-        if move__.startpos[1]==move__.endpos[1]:[m
[31m-            direction=1 if move__.startpos[0]<move__.endpos[0] else -1[m
[31m-            # if abs(endrow-startrow)==1:[m
[31m-            #     return True[m
[31m-            for i in range(1,abs(move__.endpos[0]-move__.startpos[0])):[m
[31m-                if board.board[move__.startpos[0]+(i*direction)][move__.startpos[1]] is not None:[m
[31m-                    return False[m
[31m-            if not justtest:[m
[31m-                move__.captured_piece=board.board[move__.endpos[0]][move__.endpos[1]][m
[31m-                move__.captured_piece_pos=(move__.endpos[0],move__.endpos[1])[m
[31m-            return move__      [m
[31m-        return False[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def is_possible_knightmove_classical(move__,board,justtest):[m
[31m-        if (abs(move__.startpos[0]-move__.endpos[0])==2 or abs(move__.startpos[0]-move__.endpos[0])==1) and \[m
[31m-        (abs(move__.startpos[1]-move__.endpos[1])==2 or abs(move__.startpos[1]-move__.endpos[1])==1) and \[m
[31m-        (abs(move__.startpos[0]-move__.endpos[0])+abs(move__.startpos[1]-move__.endpos[1])==3):[m
[31m-            if not justtest:[m
[31m-                move__.captured_piece=board.board[move__.endpos[0]][move__.endpos[1]][m
[31m-                move__.captured_piece_pos=(move__.endpos[0],move__.endpos[1])[m
[31m-            return move__[m
[31m-        else:[m
[31m-            return False[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def is_possible_bishopmove_classical(move__,board,justtest):[m
[31m-        if abs(move__.startpos[0]-move__.endpos[0])==abs(move__.startpos[1]-move__.endpos[1]):[m
[31m-            return Rules.is_path_clear_bishop_classical(move__,board,justtest)[m
[31m-        else: [m
[31m-            return False[m
[31m-        [m
[31m-    def is_path_clear_bishop_classical(move__,board,justtest):[m
[31m-        if move__.startpos[0]>move__.endpos[0] and move__.startpos[1]>move__.endpos[1]:[m
[31m-            direction=(-1,-1)[m
[31m-        elif move__.startpos[0]>move__.endpos[0] and move__.startpos[1]<move__.endpos[1]:[m
[31m-            direction=(-1,1)[m
[31m-        elif move__.startpos[0]<move__.endpos[0] and move__.startpos[1]>move__.endpos[1]:[m
[31m-            direction=(1,-1)[m
[31m-        elif move__.startpos[0]<move__.endpos[0] and move__.startpos[1]<move__.endpos[1]:[m
[31m-            direction=(1,1)[m
[31m-        for i in range(1,abs(move__.startpos[0]-move__.endpos[0])):[m
[31m-            if board.board[move__.startpos[0]+(direction[0]*i)][move__.startpos[1]+(direction[1]*i)] is not None:[m
[31m-                return False[m
[31m-        if not justtest:[m
[31m-            move__.captured_piece=board.board[move__.endpos[0]][move__.endpos[1]][m
[31m-            move__.captured_piece_pos=(move__.endpos[0],move__.endpos[1])[m
[31m-        return move__[m
[31m-    [m
[31m-    @staticmethod[m
[31m-    def is_possible_queenmove_classical(move__,board,justtest):[m
[31m-        if abs(move__.startpos[0]-move__.endpos[0])==abs(move__.startpos[1]-move__.endpos[1]):[m
[31m-            return Rules.is_path_clear_bishop_classical(move__,board,justtest)[m
[31m-        if move__.startpos[0]==move__.endpos[0] or move__.startpos[1]==move__.endpos[1]:[m
[31m-            return Rules.is_path_clear_rook_classical(move__,board,justtest)[m
[31m-        return False[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def is_possible_kingmove_classical(move__,board,justtest):[m
[31m-        if abs(move__.startpos[0]-move__.endpos[0])<=1 and abs(move__.startpos[1]-move__.endpos[1])<=1:[m
[31m-            print("normal kingmove")[m
[31m-            return move__[m
[31m-        #checking castle[m
[31m-        if not any(move__.piece==tup.piece for tup in board.move_list):[m
[31m-            if not Rules.checking_check(move__.piece.color,board): [m
[31m-                if move__.piece.color=="white":[m
[31m-                    direction=1 if move__.startpos[1]-move__.endpos[1]<0 else -1[m
[31m-                    if move__.piece.position==(7,4):[m
[31m-                        if abs(move__.startpos[1]-move__.endpos[1])==2 and move__.endpos[0]==move__.endpos[0]:[m
[31m-                            if direction==1:[m
[31m-                                if isinstance(board.board[7][7],Rook):[m
[31m-                                    if any(board.board[7][7]==tup.piece for tup in board.move_list):[m
[31m-                                        return False[m
[31m-                                    for j in range(1,3):[m
[31m-                                        if board.board[move__.endpos[0]][move__.startpos[1]+(direction*j)]!=None:[m
[31m-                                            return False[m
[31m-                                        for p in board.blackpieces:[m
[31m-                                            move_=ChessMove((p.position[0],p.position[1]),(move__.endpos[0],move__.startpos[1]+(direction*j)),p)[m
[31m-                                            if Rules.is_possible_move(move_,board,justtest=True):[m
[31m-                                                return False[m
[31m-                                    if not justtest:[m
[31m-                                        move__.castle_secondpiece=board.board[7][7]  [m
[31m-                                        move__.castle_secondpiece_pos=(7,7)     [m
[31m-                                else:[m
[31m-                                    return False[m
[31m-                            elif direction==-1:[m
[31m-                                if isinstance(board.board[7][0],Rook):[m
[31m-                                    if any(board.board[7][0]==tup.piece for tup in board.move_list):[m
[31m-                                        return False[m
[31m-                                    for j in range(1,4):[m
[31m-                                        if board.board[move__.endpos[0]][move__.startpos[1]+(direction*j)]!=None:[m
[31m-                                            return False[m
[31m-                                        for p in board.blackpieces:[m
[31m-                                            move_=ChessMove((p.position[0],p.position[1]),(move__.endpos[0],move__.startpos[1]+(direction*j)),p)[m
[31m-                                            if Rules.is_possible_move(move_,board,justtest=True):[m
[31m-                                                return False[m
[31m-                                    if not justtest:[m
[31m-                                        move__.castle_secondpiece=board.board[7][0][m
[31m-                                        move__.castle_secondpiece_pos=(7,0)   [m
[31m-                                else:[m
[31m-                                    return False[m
[31m-                            if not justtest:[m
[31m-                                move__.is_castle=True[m
[31m-                            print("white castlemove")[m
[31m-                            return move__[m
[31m-                if move__.piece.color=="black":[m
[31m-                    direction=1 if move__.startpos[1]-move__.endpos[1]<0 else -1[m
[31m-                    print(direction)[m
[31m-                    if move__.piece.position==(0,4):[m
[31m-                        print("king correct")[m
[31m-                        if abs(move__.startpos[1]-move__.endpos[1])==2 and move__.endpos[0]==move__.endpos[0]:[m
[31m-                            if direction==1:[m
[31m-                                print("if dir 1")[m
[31m-                                if isinstance(board.board[0][7],Rook):[m
[31m-                                    if any(board.board[0][7]==tup.piece for tup in board.move_list):[m
[31m-                                        print("rook already moved")[m
[31m-                                        return False[m
[31m-                                    for j in range(1,3):    [m
[31m-                                        if board.board[move__.endpos[0]][move__.startpos[1]+direction*j]!=None:[m
[31m-                                            print("piece in the way")[m
[31m-                                            return False[m
[31m-                                        for p in board.whitepieces:[m
[31m-                                            move_=ChessMove((p.position[0],p.position[1]),(move__.endpos[0],move__.startpos[1]+(direction*j)),p)[m
[31m-                                            if Rules.is_possible_move(move_,board,justtest=True):[m
[31m-                                                print("check so no castle")[m
[31m-                                                return False[m
[31m-                                    if not justtest:[m
[31m-                                        move__.castle_secondpiece=board.board[0][7] [m
[31m-                                        move__.castle_secondpiece_pos=(0,7)[m
[31m-                                    print(move__.castle_secondpiece.position)  [m
[31m-                                else:[m
[31m-                                    print("no rook in corner")[m
[31m-                                    return False[m
[31m-                            elif direction==-1:[m
[31m-                                if isinstance(board.board[0][0],Rook):[m
[31m-                                    if any(board.board[0][0]==tup.piece for tup in board.move_list):[m
[31m-                                        return False[m
[31m-                                    for j in range(1,4):[m
[31m-                                        if board.board[move__.endpos[0]][move__.startpos[1]+direction*j]!=None:[m
[31m-                                            return False[m
[31m-                                        for p in board.whitepieces:[m
[31m-                                            move_=ChessMove((p.position[0],p.position[1]),(move__.endpos[0],move__.startpos[1]+(direction*j)),p)[m
[31m-                                            if Rules.is_possible_move(move_,board,justtest=True):[m
[31m-                                                return False[m
[31m-                                    if not justtest:[m
[31m-                                        move__.castle_secondpiece=board.board[0][0][m
[31m-                                        move__.castle_secondpiece_pos=(0,0)   [m
[31m-                                else: [m
[31m-                                    return False[m
[31m-                            if not justtest:[m
[31m-                                move__.is_castle=True[m
[31m-                                print(move__.is_castle)[m
[31m-                            return move__[m
[31m-        return False[m
[31m-[m
[31m-    @staticmethod #if endsquare has an own piece on it[m
[31m-    def is_own_piece(move__,board):[m
[31m-        if board.board[move__.endpos[0]][move__.endpos[1]]!=None:[m
[31m-            if move__.piece.color==board.board[move__.endpos[0]][move__.endpos[1]].color:[m
[31m-                return True[m
[31m-            return False[m
[31m-        return False[m
[31m-    [m
[31m-    @staticmethod #if the given color is in check[m
[31m-    def checking_check(color,board):[m
[31m-        if board.ruleset_=="classical":[m
[31m-            # print("now checking check")[m
[31m-            print("color that is in check..checking",color)[m
[31m-            king_position=board.piece_lookup["K",color][0].position[m
[31m-            print(king_position)[m
[31m-            if color=="white":[m
[31m-                for piece_ in board.blackpieces:[m
[31m-                    # print(piece_)[m
[31m-                    # print(piece_.position)[m
[31m-                    if not isinstance(piece_,King):[m
[31m-                        move_to_try=ChessMove((piece_.position[0],piece_.position[1]),(king_position[0],king_position[1]),piece_)[m
[31m-                        if Rules.is_possible_move(move_to_try,board,justtest=True): #..[m
[31m-                            # print("check detected")[m
[31m-                            print(piece_.position)[m
[31m-                            return True[m
[31m-                # print("no check detected")[m
[31m-                return False[m
[31m-            if color=="black":[m
[31m-                for piece_ in board.whitepieces:[m
[31m-                    move_to_try=ChessMove((piece_.position[0],piece_.position[1]),(king_position[0],king_position[1]),piece_)[m
[31m-                    if Rules.is_possible_move(move_to_try,board,justtest=True):[m
[31m-                        print(move_to_try.startpos)[m
[31m-                        print(move_to_try.endpos)[m
[31m-                        print("white figure chess,", piece_)[m
[31m-                        return True[m
[31m-                return False[m
[31m-            # print("no check detected")[m
[31m-            return False[m
[31m-        [m
[31m-    [m
[31m-    @staticmethod #if the given color is in mate[m
[31m-    def checking_mate(color,board):[m
[31m-        print("checking the mate...")[m
[31m-        # print(board.board[1][5])[m
[31m-        # print(board.blackpieces)[m
[31m-        # print(len(board.blackpieces))[m
[31m-        if board.ruleset_=="classical":[m
[31m-            if Rules.checking_check(color,board):[m
[31m-                if color=="white":[m
[31m-                    for piece in board.whitepieces:[m
[31m-                        for r in range(8):[m
[31m-                            for c in range(8):[m
[31m-                                move_=ChessMove((piece.position[0],piece.position[1]),(r,c),piece)[m
[31m-                                if Rules.is_valid_move(move_,board,justtest=True):[m
[31m-                                    print("there is a move")[m
[31m-                                    return False[m
[31m-                    print("checkmate!")[m
[31m-                    [m
[31m-                    return True[m
[31m-                if color=="black":[m
[31m-                    for piece in board.blackpieces:[m
[31m-                        # print(piece.position)[m
[31m-                        # print(board.board[1][5])[m
[31m-                        for r in range(8):[m
[31m-                            for c in range(8):[m
[31m-                                move_=ChessMove((piece.position[0],piece.position[1]),(r,c),piece)[m
[31m-                                if Rules.is_valid_move(move_,board,justtest=True):[m
[31m-                                    print("no checkmate!")[m
[31m-                                    return False[m
[31m-                    print("checkmate!")[m
[31m-                    return True[m
[31m-            else:[m
[31m-                return False[m
[31m-    [m
[31m-    @staticmethod #if move is possible, it does the move and checking for check and take the move back[m
[31m-    def testing_move(move__,board,promotion_choice,justtest):[m
[31m-        print(move__)[m
[31m-        move__.promotion_choice=(Rook(move__.piece.color)) #just to check if there s a check after[m
[31m-        board.make_move(move__)[m
[31m-        print("pawnpos",move__.piece.position)[m
[31m-        print("whats on the square",board.board[move__.startpos[0]][move__.startpos[1]])[m
[31m-        if Rules.checking_check(move__.piece.color,board):[m
[31m-            board.take_move_back(move__)[m
[31m-            move__.promotion_choice=None[m
[31m-            print("there was a check")[m
[31m-            return False[m
[31m-        else:[m
[31m-            board.take_move_back(move__)[m
[31m-            move__.promotion_choice=None[m
[31m-            print("testing finished")[m
[31m-            print(move__)[m
[31m-            if move__.is_promotion:[m
[31m-                if not justtest:[m
[31m-                    while move__.promotion_choice==None:[m
[31m-                        choice=promotion_choice(move__.piece.color)[m
[31m-                        if choice=="Queen":[m
[31m-                            move__.promotion_choice=((Queen(move__.piece.color)))[m
[31m-                        elif choice=="Rook":[m
[31m-                            move__.promotion_choice=((Rook(move__.piece.color)))[m
[31m-                        elif choice=="Bishop":[m
[31m-                            move__.promotion_choice=((Bishop(move__.piece.color)))[m
[31m-                        elif choice=="Knight":[m
[31m-                            move__.promotion_choice=((Knight(move__.piece.color)))[m
[31m-            return move__[m
[31m-    [m
[31m-    # @staticmethod[m
[31m-    # def extract_moves_from_informations(piece,startrow,startcol,endrow,endcol,ruleset,board,promotion_choice): [m
[31m-    #     if ruleset=="classical":[m
[31m-    #         moves=[][m
[31m-    #         #check castle[m
[31m-    #         if isinstance(piece,King):[m
[31m-    #             if abs(startcol-endcol)==2:[m
[31m-    #                 direction=1 if startcol-endcol<0 else -1[m
[31m-    #                 moves.append((piece,startrow,startcol,endrow,endcol))[m
[31m-    #                 if direction==1:[m
[31m-    #                     moves.append((board.board[startrow][7],startrow,7,endrow,endcol-1))[m
[31m-    #                 elif direction==-1:[m
[31m-    #                     moves.append((board.board[startrow][0],startrow,0,endrow,endcol+1))[m
[31m-    #                 return moves[m
[31m-    #         #check pawn on last row and en passant[m
[31m-    #         if isinstance(piece,Pawn):[m
[31m-    #             #check last row[m
[31m-    #             if endrow==0 or endrow==7:[m
[31m-    #                 moves.append((piece,startrow,startcol,None,None))[m
[31m-    #                 moves.append((board.board[endrow][endcol],endrow,endcol,None,None))[m
[31m-    #                 chosen_piece = None[m
[31m-    #                 while len(moves)==2:[m
[31m-    #                     chosen_piece = promotion_choice(piece.color)[m
[31m-    #                     if chosen_piece=="Queen":[m
[31m-    #                         moves.append((Queen(piece.color),None,None,endrow,endcol))[m
[31m-    #                     elif chosen_piece=="Rook":[m
[31m-    #                         moves.append((Rook(piece.color),None,None,endrow,endcol))[m
[31m-    #                     elif chosen_piece=="Bishop":[m
[31m-    #                         moves.append((Bishop(piece.color),None,None,endrow,endcol))[m
[31m-    #                     elif chosen_piece=="Knight":[m
[31m-    #                         moves.append((Knight(piece.color),None,None,endrow,endcol))[m
[31m-    #                 return moves[m
[31m-    #             #en passant[m
[31m-    #             if abs(startcol-endcol)==1 and board.board[endrow][endcol]==None:[m
[31m-    #                 moves.append((piece,startrow,startcol,endrow,endcol))[m
[31m-    #                 try:[m
[31m-    #                     moves.append((board.board[startrow][endcol],startrow,endcol,None,None))[m
[31m-    #                 except AttributeError:[m
[31m-    #                     pass[m
[31m-    #                 return moves[m
[31m-    #         return [(piece,startrow,startcol,endrow,endcol)][m
[31m-[m
[31m-[m
[31m-[m
[31m-            [m
[1mdiff --git a/main.py b/main.py[m
[1mdeleted file mode 100644[m
[1mindex 3f330b4..0000000[m
[1m--- a/main.py[m
[1m+++ /dev/null[m
[36m@@ -1,13 +0,0 @@[m
[31m-import tkinter as tk[m
[31m-from chesspieces import *[m
[31m-from chessrules import *[m
[31m-from chessmove import *[m
[31m-from chessgui import *[m
[31m-from chessboard import *[m
[31m-from chessgame import *[m
[31m-[m
[31m-if __name__== "__main__":[m
[31m-    root=tk.Tk()[m
[31m-    game=ChessGame(root)[m
[31m-    gui=ChessGUI(root,game)[m
[31m-    root.mainloop()[m
\ No newline at end of file[m
